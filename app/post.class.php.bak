<?php
defined('PROJECT_PATH') OR exit('No direct script access allowed');

class Post
{
	private static function login_protected(){
		if(!User::is_logged_in()){
			throw new Exception(__("You need to be logged in to perform this action."));
		}
	}

// EMOJI MAP - Muss mit JavaScript Ã¼bereinstimmen! (44 Emojis)
private static function get_emoji_map(){
	return [
		':grinning:' => 'ðŸ˜€',
		':smiley:' => 'ðŸ˜ƒ',
		':smile:' => 'ðŸ˜„',
		':grin:' => 'ðŸ˜',
		':laughing:' => 'ðŸ˜†',
		':joy:' => 'ðŸ˜‚',
		':rofl:' => 'ðŸ¤£',
		':blush:' => 'ðŸ˜Š',
		':innocent:' => 'ðŸ˜‡',
		':heart_eyes:' => 'ðŸ˜',
		':smiling_face_with_hearts:' => 'ðŸ¥°',
		':kissing_heart:' => 'ðŸ˜˜',
		':kissing:' => 'ðŸ˜—',
		':sunglasses:' => 'ðŸ˜Ž',
		':star_struck:' => 'ðŸ¤©',
		':hugging:' => 'ðŸ¤—',
		':thinking:' => 'ðŸ¤”',
		':neutral_face:' => 'ðŸ˜',
		':expressionless:' => 'ðŸ˜‘',
		':no_mouth:' => 'ðŸ˜¶',
		':eye_roll:' => 'ðŸ™„',
		':smirk:' => 'ðŸ˜',
		':persevere:' => 'ðŸ˜£',
		':disappointed_relieved:' => 'ðŸ˜¥',
		':open_mouth:' => 'ðŸ˜®',
		':zipper_mouth:' => 'ðŸ¤',
		':hushed:' => 'ðŸ˜¯',
		':sleepy:' => 'ðŸ˜ª',
		':tired_face:' => 'ðŸ˜«',
		':yawning:' => 'ðŸ¥±',
		':sleeping:' => 'ðŸ˜´',
		':relieved:' => 'ðŸ˜Œ',
		':stuck_out_tongue:' => 'ðŸ˜›',
		':stuck_out_tongue_winking_eye:' => 'ðŸ˜œ',
		':stuck_out_tongue_closed_eyes:' => 'ðŸ˜',
		':drooling:' => 'ðŸ¤¤',
		':unamused:' => 'ðŸ˜’',
		':sweat:' => 'ðŸ˜“',
		':pensive:' => 'ðŸ˜”',
		':confused:' => 'ðŸ˜•',
		':upside_down:' => 'ðŸ™ƒ',
		':melting:' => 'ðŸ« ',
		':money_mouth:' => 'ðŸ¤‘',
		':astonished:' => 'ðŸ˜²',
	];
}

	private static function parse_content($c){
		// Ersetze [*] Listenpunkte durch <li> Tags
		$c = preg_replace('/\[\*\]([^\[\*]+)/i', '<li>$1</li>', $c);
		
		$parser = new JBBCode\Parser();
		$parser->addCodeDefinitionSet(new JBBCode\DefaultCodeDefinitionSet());

		if(Config::get("highlight")){
			$c = str_replace("\t", "  ", $c);
			$c = preg_replace("/\[code(?:=([^\[]+))?\]\s*?(?:\n|\r)?/i", '[code=$1]', $c);
			$c = preg_replace("/\[\/code\]\s*?(?:\n|\r)?/i", '[/code]', $c);

			$parser->addCodeDefinition(new class extends \JBBCode\CodeDefinition {
				public function __construct(){
					parent::__construct();
					$this->setTagName("code");
					$this->setParseContent(false);
					$this->setUseOption(true);
				}

				public function asHtml(\JBBCode\ElementNode $el){
					$content = $this->getContent($el);
					$class = $el->getAttribute()['code'];
					return '<code class="'.$class.'">'.htmlentities($content).'</code>';
				}
			});
		}

		$builder = new JBBCode\CodeDefinitionBuilder("goal", "<div class=\"b_goal star\">{param}</div>");
		$parser->addCodeDefinition($builder->build());

		$builder = new JBBCode\CodeDefinitionBuilder("goal", "<div class=\"b_goal {option}\">{param}</div>");
		$builder->setUseOption(true);
		$parser->addCodeDefinition($builder->build());

		if(($tags = Config::get_safe("bbtags", [])) && !empty($tags)){
			foreach($tags as $tag => $content){
				$builder = new JBBCode\CodeDefinitionBuilder($tag, $content);
				$parser->addCodeDefinition($builder->build());
			}
		}

		$parser->parse($c);

		$parser->accept(new class implements \JBBCode\NodeVisitor{
			function visitDocumentElement(\JBBCode\DocumentElement $documentElement){
				foreach($documentElement->getChildren() as $child) {
					$child->accept($this);
				}
			}

			function visitTextNode(\JBBCode\TextNode $textNode){
				$c = $textNode->getValue();
				$c = preg_replace('/\"([^\"]+)\"/i', "â€ž$1\"", $c);
				$c = htmlentities($c);
				$c = preg_replace('/\*([^\*]+)\*/i', "<strong>$1</strong>", $c);
				$c = preg_replace('/(https?\:\/\/[^\" \n]+)/i', "<a href=\"\\0\" target=\"_blank\">\\0</a>", $c);
				$c = preg_replace('/(\#[A-Za-z0-9-_]+)(\s|$)/i', "<span class=\"tag\">\\1</span>\\2", $c);
				$c = nl2br($c);
				$textNode->setValue($c);
			}

			function visitElementNode(\JBBCode\ElementNode $elementNode){
				if ($elementNode->getCodeDefinition()->parseContent()) {
					foreach ($elementNode->getChildren() as $child) {
						$child->accept($this);
					}
				}
			}
		});

		return $parser->getAsHtml();
	}

	private static function raw_data($raw_input){
		$default_input = [
			"text" => '',
			"plain_text" => '',
			"feeling" => '',
			"persons" => '',
			"location" => '',
			"content_type" => '',
			"content" => '',
			"privacy" => ''
		];

		$raw_output = array();
		foreach($default_input as $key => $def){
			if(array_key_exists($key, $raw_input)){
				$raw_output[$key] = $raw_input[$key];
			} else {
				$raw_output[$key] = $default_input[$key];
			}
		}

		if($raw_output['privacy'] != "public" && $raw_output['privacy'] != "friends"){
			$raw_output['privacy'] =  "private";
		}

		return $raw_output;
	}

	public static function insert($r){
		self::login_protected();

		$data = self::raw_data($r);

		if(empty($data['text'])){
			throw new Exception(__("No data."));
		}

		// WICHTIG: Speichere plain_text mit BBCode und Emoji-Codes
		$data['plain_text'] = $data['text'];

		// Konvertiere Emoji-Codes zu Emojis fÃ¼r die Anzeige
		$display_text = $data['text'];
		foreach(self::get_emoji_map() as $code => $emoji){
			$display_text = str_replace($code, $emoji, $display_text);
		}

		// Parse BBCode nur fÃ¼r Anzeige
		$data['text'] = self::parse_content($display_text);
		$data['datetime'] = time();  // Unix Timestamp
		$data['status'] = '1';

		$data['id'] = DB::get_instance()->insert('posts', $data)->last_id();
		$data['datetime'] = date("d M Y H:i");

		return $data;
	}

	public static function update($r){
		self::login_protected();

		$data = self::raw_data($r);
		
		// WICHTIG: Speichere plain_text mit BBCode und Emoji-Codes
		$data['plain_text'] = $data['text'];

		// Konvertiere Emoji-Codes zu Emojis fÃ¼r die Anzeige
		$display_text = $data['text'];
		foreach(self::get_emoji_map() as $code => $emoji){
			$display_text = str_replace($code, $emoji, $display_text);
		}

		// Parse BBCode nur fÃ¼r Anzeige
		$data['text'] = self::parse_content($display_text);

		DB::get_instance()->update('posts', $data, "WHERE `id` = ? AND `status` <> 5", $r["id"]);

		return $data;
	}

	public static function hide($r){
		self::login_protected();
		DB::get_instance()->query("
			UPDATE `posts`
			SET `status` = 4
			WHERE `id` = ?
			AND `status` <> 5
		", $r["id"]);
		return true;
	}

	public static function show($r){
		self::login_protected();
		DB::get_instance()->query("
			UPDATE `posts`
			SET `status` = 1
			WHERE `id` = ?
			AND `status` <> 5
		", $r["id"]);
		return true;
	}

	public static function delete($r){
		self::login_protected();
		DB::get_instance()->query("
			DELETE FROM `posts`
			WHERE `id` = ?
		", $r["id"]);
		return true;
	}

	// Sticky Post Toggle
	public static function toggle_sticky($r){
		self::login_protected();
		
		// Get current sticky status
		$current = DB::get_instance()->query("
			SELECT `is_sticky`
			FROM `posts`
			WHERE `id` = ?
		", $r["id"])->first();
		
		if(!$current){
			throw new Exception(__("Post not found."));
		}
		
		// Toggle: 0 -> 1, 1 -> 0
		$new_status = $current['is_sticky'] ? 0 : 1;
		
		DB::get_instance()->query("
			UPDATE `posts`
			SET `is_sticky` = ?
			WHERE `id` = ?
		", $new_status, $r["id"]);
		
		return array("is_sticky" => $new_status);
	}

	public static function edit_data($r){
		self::login_protected();
		return DB::get_instance()->query("
			SELECT `plain_text`, `feeling`, `persons`, `location`, `privacy`, `content_type`, `content`
			FROM `posts`
			WHERE `id` = ?
			AND `status` <> 5
		", $r["id"])->first();
	}

	public static function get_date($r){
		self::login_protected();

		if (DB::connection() === 'sqlite') {
			$datetime = "strftime('%Y %m %d %H %M', `posts`.`datetime`)";
		} else if (DB::connection() === 'postgres') {
			$datetime = "to_char(datetime,'YYYY MM DD HH24 MI')";
		} else {
			$datetime = "DATE_FORMAT(`datetime`,'%Y %c %e %k %i')";
		}

		$date = DB::get_instance()->query("
			SELECT $datetime AS `date_format`
			FROM `posts`
			WHERE `id` = ?
			AND `status` <> 5
		", $r["id"])->first("date_format");
		$date = array_map("intval", explode(" ", $date));
		$date[4]  = floor($date[4]/10)*10;
		return $date;
	}

	public static function set_date($r){
		self::login_protected();

		$d = $r["date"];
		if (DB::connection() === 'sqlite') {
			$datetime = vsprintf("%04d-%02d-%02d %02d:%02d", $d);
		} else {
			$datetime = vsprintf("%04d/%02d/%02d %02d:%02d", $d);
		}

		DB::get_instance()->query("
			UPDATE `posts`
			SET `datetime` = ?
			WHERE `id` = ?
			AND `status` <> 5
		", $datetime, $r["id"]);
		return [ "datetime" => date("d M Y H:i", strtotime($datetime)) ];
	}

	public static function parse_link($r){
		self::login_protected();
		$l = $r["link"];

		preg_match('/^https?:\/\/([^:\/\s]+)([^\/\s]*\/)([^\.\s]+)\.(jpe?g|png|gif)((\?|\#)(.*))?$/i', $l, $img);
		if($img){
			return [
				"valid" => true,
				"content_type" => "img_link",
				"content" => [
					"src" => $l,
					"host" => $img[1]
				]
			];
		}

		preg_match('/^https?:\/\/(www\.)?([^:\/\s]+)(.*)?$/i', $l, $url);
		$curl_request_url = $l;

		$ch = curl_init();
		curl_setopt($ch, CURLOPT_HEADER, 0);
		curl_setopt($ch, CURLOPT_ENCODING , "");
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
		curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);
		curl_setopt($ch, CURLOPT_USERAGENT, "Mozilla/5.0 (compatible; Proxycat/1.1)");
		curl_setopt($ch, CURLOPT_REFERER, '');
		curl_setopt($ch, CURLOPT_TIMEOUT, 7);

		if($proxy = Config::get_safe("proxy", false)){
			$proxytype = Config::get_safe("proxytype", false);
			$proxyauth = Config::get_safe("proxyauth", false);
			if($proxytype === 'URL_PREFIX'){
				$curl_request_url = $proxy.$curl_request_url;
				if($proxyauth){
					curl_setopt($ch, CURLOPT_USERPWD, $proxyauth);
				}
			} else {
				curl_setopt($ch, CURLOPT_PROXY, $proxy);
				if($proxyauth){
					curl_setopt($ch, CURLOPT_PROXYUSERPWD, $proxyauth);
				}
				switch ($proxytype) {
					case 'CURLPROXY_SOCKS4':
						$proxytype = CURLPROXY_SOCKS4;
						break;
					case 'CURLPROXY_SOCKS5':
						$proxytype = CURLPROXY_SOCKS5;
						break;
					case 'CURLPROXY_HTTP':
					default:
						$proxytype = CURLPROXY_HTTP;
						break;
				}

				curl_setopt($ch, CURLOPT_PROXYTYPE, $proxytype);
			}
		}

		curl_setopt($ch, CURLOPT_URL, $curl_request_url);
		$html = curl_exec($ch);
		curl_close($ch);

		$doc = new DOMDocument();
		@$doc->loadHTML('<?xml encoding="utf-8" ?>'.$html);

		$nodes = $doc->getElementsByTagName('title');
		$title = $nodes->item(0)->nodeValue;

		$content = [
			"link" => $l,
			"title" => ($title ? $title : $url[2]),
			"is_video" => false,
			"host" => $url[2]
		];

		$metas = $doc->getElementsByTagName('meta');
		for($i = 0; $i < $metas->length; $i++){
			$meta = $metas->item($i);

			$n = $meta->getAttribute('name');
			$p = $meta->getAttribute('property');
			$c = $meta->getAttribute('content');

			if($n == 'twitter:description' || $p == 'og:description' || $n == 'description'){
				$content["desc"] = substr($c, 0, 180);
			}

			if($n == 'twitter:title' || $p == 'og:title' || $p == 'title'){
				$content["title"] = $c;
			}

			if($p == 'og:url'){
				$content["link"] = $c;
			}

			if($p == 'og:type'){
				$content["is_video"] = (preg_match("/video/", $c));
			}

			if($n == 'twitter:image:src' || $p == 'og:image'){
				if(preg_match("/^(https?:)?\/\//", $c)) {
					$content["thumb"] = $c;
				} elseif(preg_match("/^\//", $c)) {
					preg_match("/^((?:https?:)?\/\/([^\/]+))(\/|$)/", $l, $m);
					$content["thumb"] = $m[1].'/'.$c;
				} else {
					preg_match("/^((?:https?:)?\/\/[^\/]+.*?)(\/[^\/]*)?$/", $l, $m);
					$content["thumb"] = $m[1].'/'.$c;
				}
			}

			if($n == 'twitter:domain'){
				$content["host"] = $c;
			}
		}

		return [
			"valid" => true,
			"content_type" => "link",
			"content" => $content
		];
	}

	public static function upload_image(){
		self::login_protected();
		return Image::upload();
	}

	public static function load($r){
		$from = [];
		if(preg_match("/^[0-9]{4}-[0-9]{2}$/", @$r["filter"]["from"])){
			$from = $r["filter"]["from"]."-01 00:00";
		}
		if(preg_match("/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/", @$r["filter"]["from"])){
			$from = $r["filter"]["from"]." 00:00";
		}

		$to = [];
		if(preg_match("/^[0-9]{4}-[0-9]{2}$/", @$r["filter"]["to"])){
			$to = $r["filter"]["to"]."-01 00:00";
		}
		if(preg_match("/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/", @$r["filter"]["to"])){
			$to = $r["filter"]["to"]." 00:00";
		}

		$id = [];
		if(@$r["filter"]["id"]){
			$id = intval($r["filter"]["id"]);
		}

		$tag = [];
		if(preg_match("/^[A-Za-z0-9-_]+$/", @$r["filter"]["tag"])){
			$tag = '#'.$r["filter"]["tag"];
		}

		$loc = [];
		if(@$r["filter"]["loc"]){
			$loc = $r["filter"]["loc"];
		}

		$person = [];
		if(@$r["filter"]["person"]){
			$person = $r["filter"]["person"];
		}

		$like_match = "LIKE ".DB::concat("'%'", "?", "'%'");

		// Lade Posts mit datetime als Integer (Unix Timestamp)
		$posts = DB::get_instance()->query("
			SELECT
				`id`, `plain_text`, `feeling`, `persons`, `location`, `privacy`, `content_type`, `content`,
				`datetime`, (`status` <> 1) AS `is_hidden`, `is_sticky`
			FROM `posts`
			WHERE ".
				(!User::is_logged_in() ? (User::is_visitor() ? "`privacy` IN ('public', 'friends') AND " : "`privacy` = 'public' AND ") : "").
				($from ? "`posts`.`datetime` > ? AND " : "").
				($to ? "`posts`.`datetime` < ? AND " : "").
				($id ? "`id` = ? AND " : "").
				($tag ? "`plain_text` $like_match AND " : "").
				($loc ? "`location` $like_match AND " : "").
				($person ? "`persons` $like_match AND " : "").
				"`status` <> 5
			ORDER BY 
				`is_sticky` DESC,
				`posts`.`id` ".(@$r["sort"] == 'reverse' ? "ASC" : "DESC")."
			LIMIT ? OFFSET ?
			", $from, $to, $id, $tag, $loc, $person, $r["limit"], $r["offset"]
		)->all();

		// Parse BBCode beim Laden und formatiere datetime
		foreach($posts as &$post){
			// Konvertiere Unix Timestamp zu lesbarem Format
			if(!empty($post['datetime'])){
				$post['datetime'] = date("d M Y H:i", intval($post['datetime']));
			}
			
			$display_text = $post['plain_text'];
			
			// Konvertiere Emoji-Codes zu Emojis
			foreach(self::get_emoji_map() as $code => $emoji){
				$display_text = str_replace($code, $emoji, $display_text);
			}
			
			$post['text'] = self::parse_content($display_text);
		}

		return $posts;
	}

	public static function login($r){
		return User::login($r["nick"], $r["pass"]);
	}

	public static function logout(){
		return User::logout();
	}

	public static function handshake($r){
		return ["logged_in" => User::is_logged_in(), "is_visitor" => User::is_visitor()];
	}
}